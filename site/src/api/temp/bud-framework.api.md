## API Report File for "@roots/bud-framework"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts
/// <reference types="node" />

import {Class} from 'type-fest'
import {Compiler as Compiler_2} from 'webpack'
import {Configuration as Configuration_2} from 'webpack'
import {Container} from '@roots/container'
import {Instance as Instance_2} from 'ink'
import {MultiCompiler} from 'webpack'
import {ProgressPlugin} from 'webpack'
import {RuleSetRule} from 'webpack'
import {Server as Server_2} from 'http'
import {Signale} from 'signale'
import {StatsCompilation} from 'webpack'
import {StatsError} from 'webpack'
import * as Webpack from 'webpack'

// @public
abstract class Abstract
  extends Service
  implements Cache_2.Interface
{
  abstract buildDependencies(): string[]
  abstract directory(): string
  abstract hash(): string
  abstract version(): string
}

// @public
abstract class Abstract_2 extends Service<Peers.Repository> {
  abstract getProjectInfo(): {
    [key: string]: any
  }
  abstract hasPeerDependency(pkg: string): boolean
  abstract peers: Peers.Interface
  resolveFrom: string[]
}

// @public
abstract class Abstract_3 implements Peers.Interface {
  abstract discover(
    type: 'dependencies' | 'devDependencies',
  ): this
  abstract getPeerManifest(name: string): {
    [key: string]: any
  }
  abstract install(): void
  abstract isExtension(name: string): boolean
  abstract project: Project.Interface
  abstract registerDiscovered(): void
  abstract resolvePeerByName(name: string): string
}

// @public
export interface Api extends Service {
  // (undocumented)
  name: string
}

// @public
interface Application extends Loose {
  // (undocumented)
  listen(on: string | number, cb: CallableFunction): Instance
}

// @public
interface ApplyPlugin extends Loose {
  // (undocumented)
  apply(...args: any[]): unknown
}

// @public
export type AtLeastOne<Type = unknown> = Type | Type[]

// @public
export abstract class Bootstrapper<
  T = any,
> extends Container<T> {
  constructor(app: Framework)
  get app(): Framework
  name: any
}

declare namespace Build {
  export {Build_2 as Interface, Build_3 as Abstract}
}
export {Build}

// @public
interface Build_2 extends Service {
  config: Webpack.Configuration
  items: Items
  loaders: Loaders
  rebuild(): Webpack.Configuration
  rules: Rules
}

// @public
class Build_3 extends Service {
  config: Webpack.Configuration
  items: Item.Interface[]
  loaders: Loader.Interface[]
  rules: Rule.Interface[]
}

declare namespace Cache_2 {
  export {Interface_2 as Interface, Abstract}
}
export {Cache_2 as Cache}

// Warning: (ae-internal-mixed-release-tag) Mixed release tags are not allowed for "Compiler" because one of its declarations is marked as @internal
//
// @public
export interface Compiler extends Service {
  before(): any
  callback(err: StatsError, stats: StatsCompilation): void
  compile(): Compiler.Instance
  instance: Compiler.Instance
  isCompiled: boolean
  progress: Compiler.Progress
  stats: StatsCompilation
}

// @internal
export namespace Compiler {
  // (undocumented)
  export type Config = Configuration_2
  // (undocumented)
  export type Instance = Compiler_2 | MultiCompiler
  // (undocumented)
  export type Progress = any
  // (undocumented)
  export namespace Progress {
    // (undocumented)
    export type Handler = ProgressPlugin['handler']
  }
}

// @public
interface CompilerPlugin<Plugin = ApplyPlugin, Options = unknown>
  extends Module_2 {
  apply?: Plugin & ApplyPlugin['apply']
  make?: Maybe<
    [Container<Options>, Framework],
    Plugin & ApplyPlugin
  >
  // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: No member was found with name "name"
  //
  // (undocumented)
  name: Module_2['name']
  // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: No member was found with name "options"
  //
  // (undocumented)
  options?: Maybe<[Framework], Options>
  // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: No member was found with name "when"
  //
  // (undocumented)
  when?: Module_2['when']
}

// @public
export interface Configuration {
  build: Partial<Webpack.Configuration>
  clean: boolean
  cli: boolean
  debug: boolean
  discover: boolean
  extension: Index<any>
  fileFormat: string
  hash: boolean
  hashFormat: string
  html: boolean
  install: boolean
  location: Locations
  log: boolean
  manifest: boolean
  minimize: boolean
  name: string
  patterns: Index<RegExp>
  server: Server.Configuration
  theme: {
    spacing: number
    colors: {
      foreground: TermColor
      faded: TermColor
      primary: TermColor
      primaryAlt: TermColor
      error: TermColor
      errorAlt: TermColor
      warning: TermColor
      success: TermColor
      accent: TermColor
      flavor: TermColor
    }
    screens: [
      [number, number],
      [number, number],
      [number, number],
      [number, number],
    ]
    columns: number
    maxWidth: number
    maxHeight: number
  }
}

// @public
interface Configuration_3 {
  browser: {
    log: boolean
    indicator: boolean
    overlay: boolean
  }
  disableHostCheck?: boolean
  filename?: string
  headers?: Index<string>
  host: string
  index?: string
  methods?: string[]
  middleware: Index<boolean>
  mimeTypes?: {
    [type: string]: string
  }
  port: number
  proxy: {
    host: string
    port: number
  }
  publicPath?: string
  watch: {
    files: string[]
  }
}

// @public
export type Constructor = new (options: Options) => Framework

// @public
interface ConstructorOptions {
  loader: Maybe<[Framework], Loader.Interface>
  options?: Maybe<[Framework], Options_2>
}

// @public
interface Controller {
  app: Framework
  apply: Extension_2['apply']
  boot(): Controller
  get(key: Name): any
  make: Extension_2['make']
  makeKey(key: Name): Hooks.Name
  // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: This type of declaration is not supported yet by the resolver
  //
  // (undocumented)
  module: Extension_2
  // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: This type of declaration is not supported yet by the resolver
  //
  // (undocumented)
  name: Extension_2['name']
  // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: This type of declaration is not supported yet by the resolver
  //
  // (undocumented)
  options: Extension_2['options']
  register(): Controller
  set(key: Name, value: any): void
  // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: This type of declaration is not supported yet by the resolver
  //
  // (undocumented)
  when: Extension_2['when']
}

// @public
export interface Dashboard extends Service {
  instance: Instance_2
  render(Component: any, title?: string): void
  renderError(body: string, title: string): void
  run(): void
}

// @public
export interface Dependencies extends Service {
  install(
    dependencies: {
      name: string
      ver: string
      source: string
      type: 'dependencies' | 'devDependencies'
    }[],
  ): void
  messages: Container
  overrideInstallTarget(
    dep: string,
    type: 'dependencies' | 'devDependencies',
  ): boolean
}

// @public
export interface Env extends Container {
  getPublicEnv(): Index<any>
}

declare namespace Extension {
  export {
    Name,
    Extension_2 as Extension,
    ApplyPlugin,
    CompilerPlugin,
    Controller,
    Module_2 as Module,
  }
}
export {Extension}

// @public
type Extension_2<P = ApplyPlugin, O = unknown> =
  | Module_2<O>
  | CompilerPlugin<P, O>

// @public
export interface Extensions
  extends Service<Partial<Plugins | Modules>> {
  add(extension: Extension_2): void
  getEligibleWebpackModules(): Extension_2[]
  make(): ApplyPlugin[]
}

// @public
export interface Factory<P extends any[], T> {
  // (undocumented)
  (...args: P): T
}

// @public
interface Factory_2 {
  // (undocumented)
  (app: Framework): LoaderInterface
}

// @public
export abstract class Framework {
  constructor(options: Options)
  // Warning: (ae-forgotten-export) The symbol "access" needs to be exported by the entry point index.d.ts
  access: access
  api: Api
  bindMethod<T = Function>(
    key: string,
    method: T & Function,
  ): Framework
  // Warning: (ae-forgotten-export) The symbol "bootstrap" needs to be exported by the entry point index.d.ts
  //
  // (undocumented)
  bootstrap: bootstrap
  // (undocumented)
  build: Build.Interface
  cache: Cache_2.Interface
  children: Container<Index<Framework>>
  // Warning: (ae-forgotten-export) The symbol "close" needs to be exported by the entry point index.d.ts
  close: close_2
  compiler: Compiler
  // Warning: (ae-forgotten-export) The symbol "container" needs to be exported by the entry point index.d.ts
  container: container
  dashboard: Dashboard
  debug(message?: any, ...optionalArgs: any[]): void
  dependencies: Dependencies
  env: Env
  error(message?: any, ...optionalArgs: any[]): void
  extensions: Extensions
  // Warning: (ae-forgotten-export) The symbol "get" needs to be exported by the entry point index.d.ts
  get: get
  get hasChildren(): boolean
  hooks: Hooks
  abstract implementation: Constructor
  info(message?: any, ...optionalArgs: any[]): void
  get isDevelopment(): boolean
  get isParent(): boolean
  get isProduction(): boolean
  log(message?: any, ...optionalArgs: any[]): void
  logger: Logger
  // Warning: (ae-forgotten-export) The symbol "make" needs to be exported by the entry point index.d.ts
  make: make
  mode: Mode
  name: string
  parent: Framework | null
  // Warning: (ae-forgotten-export) The symbol "path" needs to be exported by the entry point index.d.ts
  path: path
  // Warning: (ae-forgotten-export) The symbol "pipe" needs to be exported by the entry point index.d.ts
  pipe: pipe
  project: Project.Interface
  // Warning: (ae-forgotten-export) The symbol "sequence" needs to be exported by the entry point index.d.ts
  sequence: typeof sequence
  server: Server.Interface
  services: Services
  // Warning: (ae-forgotten-export) The symbol "setPath" needs to be exported by the entry point index.d.ts
  setPath: setPath
  store: Store
  success(message?: any, ...optionalArgs: any[]): void
  // Warning: (ae-forgotten-export) The symbol "tap" needs to be exported by the entry point index.d.ts
  tap: tap
  warn(message?: any, ...optionalArgs: any[]): void
  // Warning: (ae-forgotten-export) The symbol "when" needs to be exported by the entry point index.d.ts
  when: when
}

// @public
export interface Hooks extends Service<Hooks.Repository> {
  filter<T = any>(id: Hooks.Name, seed?: any): T
  on(id: Hooks.Name, callback: Hooks.Hook): Framework
}

// @public
export namespace Hooks {
  // (undocumented)
  export namespace BuildHooks {
    // (undocumented)
    export interface Config extends Webpack.Configuration {
      // (undocumented)
      mode?: Mode
      // (undocumented)
      module?: {
        noParse?:
          | RegExp
          | RegExp[]
          | ((content: string) => boolean)
        parser: any
        rules?: RulesOverride
      }
      // (undocumented)
      optimization?: OptimizationOverride
      // (undocumented)
      parallelism?: Webpack.Configuration['parallelism']
    }
    // (undocumented)
    export type Dive<T, S> = {
      [K in keyof T as `build/${S & string}/${K & string}`]: T[K]
    }
    // (undocumented)
    export type Keys =
      | `build`
      | `build/${keyof Config}`
      | keyof Dive<Config['output'], 'output'>
      | 'build/output/pathInfo'
      | keyof Dive<Config['module'], 'module'>
      | keyof Dive<Config['module']['rules'], 'module/rules'>
      | keyof Dive<
          Config['module']['rules']['oneOf'],
          'module/rules/oneOf'
        >
      | 'build/module/rules/parser'
      | keyof Dive<Config['resolve'], 'resolve'>
      | keyof Dive<Config['resolveLoader'], 'resolveLoader'>
      | 'build/cache/name'
      | 'build/cache/cacheLocation'
      | 'build/cache/cacheDirectory'
      | 'build/cache/hashAlgorithm'
      | 'build/cache/managedPaths'
      | 'build/cache/version'
      | 'build/cache/type'
      | 'build/cache/buildDependencies'
      | keyof Dive<Config['experiments'], 'experiments'>
      | keyof Dive<Config['watchOptions'], 'watchOptions'>
      | keyof Dive<Config['performance'], 'performance'>
      | keyof Dive<Config['optimization'], 'optimization'>
      | keyof Dive<
          Config['optimization']['splitChunks'],
          'optimization/splitChunks'
        >
      | keyof Dive<
          Config['optimization']['splitChunks']['cacheGroups'],
          'optimization/splitChunks/cacheGroups'
        >
      | keyof Dive<
          Config['optimization']['splitChunks']['cacheGroups']['vendor'],
          'optimization/splitChunks/cacheGroups/vendor'
        >
    // (undocumented)
    export type Optimization =
      Webpack.Configuration['optimization']
    // (undocumented)
    export interface OptimizationOverride extends Optimization {
      // (undocumented)
      splitChunks: {
        cacheGroups: any
      }
    }
    // (undocumented)
    export type Rules = Webpack.Configuration['module']['rules']
    // (undocumented)
    export interface RulesOverride extends Rules {
      // (undocumented)
      oneOf: Webpack.RuleSetRule
    }
    {
    }
  }
  export type Hook<T = any> = ((value?: T) => T) | T
  // (undocumented)
  export type ItemKeys =
    | `item`
    | `item/${keyof Items}`
    | `item/${keyof Items}/loader`
    | `item/${keyof Items}/options`
    | `item/${keyof Items}/options/${string}`
  // (undocumented)
  export type Key = `${keyof Repository}`
  export type Keys = keyof {
    [K in keyof Modules | keyof Plugins as
      | `extension`
      | `extension/${K}`
      | `extension/${K}/${
          | `${keyof Modules | keyof Plugins}`
          | (`${keyof Modules | keyof Plugins}/${string}` &
              string)}`]: Extension_2
  }
  // (undocumented)
  export type LoaderKeys = `loader` | `loader/${keyof Loaders}`
  // (undocumented)
  export type LocationKeys = `location/${keyof Locations &
    string}`
  // @internal (undocumented)
  export type Name =
    | `before`
    | `after`
    | `done`
    | `${ItemKeys}`
    | `${LocationKeys}`
    | `${LoaderKeys}`
    | `${Keys}`
    | `${RuleKeys}`
    | `${BuildHooks.Keys}`
  // Warning: (ae-incompatible-release-tags) The symbol "Repository" is marked as @public, but its signature references "Name" which is marked as @internal
  export type Repository = {
    [K in Name as `${K & string}`]?: Hook[]
  }
  // (undocumented)
  export type RuleKeys =
    | `rule`
    | `rule/${keyof Rules}`
    | `rule/${keyof Rules}/${keyof Webpack.RuleSetRule}`
    | `rule/${keyof Rules}/${keyof Webpack.RuleSetRule &
        `options`}/${string}`
  {
  }
}

// @public
export type Index<T = any> = {
  [key: string]: T
}

// @public
interface Instance extends Server_2 {}

// @public
interface Interface extends Service {
  application: Application
  assets: string[]
  close(): void
  config: Container<Configuration_3>
  getWatchedFilesArray(): string[]
  inject(): void
  instance: Instance
  isWatchable: boolean
  middleware: Middleware
  run(): this
  watcher: {
    [key: string]: any
    close: CallableFunction
    on: CallableFunction
  }
}

// @public
interface Interface_2 {
  buildDependencies(): string[]
  directory(): string
  hash(): string
  version(): string
}

// @public
interface Interface_3 {
  discover(type: 'dependencies' | 'devDependencies'): this
  getPeerManifest(name: string): {
    [key: string]: any
  }
  install(): void
  isExtension(name: string): boolean
  project: Project.Interface
  registerDiscovered(): void
  registerDiscovered(): void
  resolvePeerByName(name: string): string
}

// @public
interface Interface_4 extends Service {
  getProjectInfo(): {
    [key: string]: any
  }
  hasPeerDependency(pkg: string): boolean
  peers: Peers.Interface
  resolveFrom: string[]
}

declare namespace Item {
  export {
    Item_2 as Interface,
    Item_3 as Abstract,
    Options_2 as Options,
    ConstructorOptions,
    Output,
  }
}
export {Item}

// @public
interface Item_2 {
  loader: Factory<[Framework], Loader.Interface>
  make(app: Framework): Output
  mergeOptions(options: Options_2, app: Framework): void
  options: Options_2
  setLoader(factory: Maybe<[Framework], Loader.Interface>): void
  setOptions(factory: Maybe<[Framework], Options_2>): void
}

// @public
abstract class Item_3 {
  abstract loader: Factory<[Framework], Loader.Interface>
  abstract make(app: Framework): Output
  abstract mergeOptions(options: Options_2, app: Framework): void
  abstract options: Factory<[Framework], Options_2>
  abstract setLoader(
    factory: Maybe<[Framework], Loader.Interface>,
  ): void
  abstract setOptions(
    factory: Maybe<[Framework], Options_2>,
  ): void
}

// @public @virtual
export interface Items extends Partial<Index<Item.Interface>> {}

declare namespace Loader {
  export {
    LoaderInterface as Interface,
    LoaderAbstract as Abstract,
    Factory_2 as Factory,
  }
}
export {Loader}

// @public
abstract class LoaderAbstract implements LoaderInterface {
  abstract make(app: Framework): string
  abstract normalizeInput<T = any>(
    input: Maybe<[Framework], T>,
  ): Factory<[Framework], T>
  abstract src: Factory<[Framework], string>
}

// @public
interface LoaderInterface {
  make(app: Framework): string
  normalizeInput<T = any>(
    input: Maybe<[Framework], T>,
  ): Factory<[Framework], T>
  src: Factory<[Framework], string>
}

// @public @virtual
export interface Loaders
  extends Partial<Index<Loader.Interface>> {}

// @public @virtual
export interface Locations extends Partial<Index<string>> {}

// @public
export interface Logger extends Service {
  instance: Signale
  // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: No member was found with name "name"
  //
  // (undocumented)
  name: 'logger'
}

// @public
export interface Loose {
  // (undocumented)
  [key: string]: any
}

// @public
export type Maybe<A extends any[], T> = T | Factory<A, T>

// @public
interface Middleware {
  // (undocumented)
  [key: string]: any
}

// @public
export type Mode = 'production' | 'development'

// @public @deprecated
export interface Module<P = any, O = any>
  extends Extension.Module<O> {}

// @public
interface Module_2<Options = unknown> extends Loose {
  api?: Maybe<[Framework], Index<unknown>>
  // @deprecated
  apply?: ApplyPlugin
  boot?: Factory<[Framework], unknown>
  // @deprecated
  make?: Maybe<[Container<Options>, Framework], ApplyPlugin>
  name?: Name
  options?: Maybe<[Framework], Options>
  register?: Factory<[Framework], unknown>
  when?: Maybe<[Framework, Container<Options>], boolean>
}

// @public @virtual
export interface Modules
  extends Partial<Index<Extension.Module>> {}

// @public
type Name = `${
  | (keyof Modules & string)
  | (keyof Plugins & string)}`

// @public (undocumented)
export interface Options {
  config?: Configuration
  mode?: Mode
  // @internal
  name: string
  // @internal
  parent?: Framework
  services?: Services
}

// @public
interface Options_2 {
  // (undocumented)
  [key: string]: any
}

// @public
interface Options_3
  extends Partial<{
    test: Maybe<[Framework], RegExp>
    use: Maybe<[Framework], Item.Interface[]>
    exclude: Maybe<[Framework], RegExp>
    type: Maybe<[Framework], string>
    parser: Maybe<[Framework], Parser>
    generator: Maybe<[Framework], any>
  }> {}

// @public
interface Output {
  loader: string
  options?: Options_2
}

// @public
interface Output_2
  extends Partial<{
    test: RegExp
    use?: {
      loader: string
      options?: {
        [key: string]: any
      }
    }[]
    exclude?: RegExp
    type?: string
    parser?: Parser
    generator?: any
  }> {}

// @public
interface Parser {
  // (undocumented)
  parse: (input?: string) => any
}

// @public
interface Peer {
  name: string
  source: string
  type: 'dependencies' | 'devDependencies'
  ver: string
}

declare namespace Peers {
  export {
    Peer,
    Repository,
    Abstract_3 as Abstract,
    Interface_3 as Interface,
  }
}
export {Peers}

// @public
export interface PluginInstance {
  apply: CallableFunction
}

// @public @virtual
export interface Plugins
  extends Partial<Index<Extension.CompilerPlugin>> {}

declare namespace Project {
  export {Abstract_2 as Abstract, Interface_4 as Interface}
}
export {Project}

// @public
interface Repository {
  dependencies: {
    [key: string]: string
  }
  devDependencies: {
    [key: string]: string
  }
  extensions: {
    [key: string]: Peer
  }
  name: string
  peers: {
    [key: string]: Peer
  }
}

declare namespace Rule {
  export {
    Rule_2 as Interface,
    Rule_3 as Abstract,
    Parser,
    Options_3 as Options,
    Output_2 as Output,
  }
}
export {Rule}

// @public
interface Rule_2 {
  getExclude(app: Framework): Output_2['exclude']
  getGenerator(app: Framework): any
  getParser(app: Framework): Parser
  getTest(app: Framework): RegExp
  getType(app: Framework): Output_2['type']
  getUse(app: Framework): Item.Interface[]
  make(app: Framework): Output_2 | RuleSetRule
  setExclude(exclude: Maybe<[Framework], RegExp>): void
  setGenerator(Generator: Maybe<[Framework], any>): void
  setParser(parser: Maybe<[Framework], Parser>): void
  setTest(test: Maybe<[Framework], RegExp>): void
  setType(type: Maybe<[Framework], string>): void
  setUse(use: Maybe<[Framework], Item.Interface[]>): void
  test?(app?: Framework): RuleSetRule['test']
  use?(app?: Framework): Item.Interface[]
}

// @public
abstract class Rule_3 {
  abstract getExclude(app: Framework): Output_2['exclude']
  abstract getGenerator(app: Framework): any
  abstract getParser(app: Framework): Parser
  abstract getTest(app: Framework): RegExp
  abstract getType(app: Framework): Output_2['type']
  abstract getUse(app: Framework): Item.Interface[]
  abstract make(app: Framework): Output_2 | RuleSetRule
  abstract setExclude(exclude: Maybe<[Framework], RegExp>): void
  abstract setGenerator(Generator: Maybe<[Framework], any>): void
  abstract setParser(parser: Maybe<[Framework], Parser>): void
  abstract setTest(test: Maybe<[Framework], RegExp>): void
  abstract setType(type: Maybe<[Framework], string>): void
  abstract setUse(
    use: Maybe<[Framework], Item.Interface[]>,
  ): void
  abstract test?(app?: Framework): RuleSetRule['test']
  abstract use?(app?: Framework): Item.Interface[]
}

// @public @virtual
export interface Rules extends Partial<Index<Rule.Interface>> {}

declare namespace Server {
  export {
    Application,
    Instance,
    Middleware,
    Target,
    Interface,
    Configuration_3 as Configuration,
  }
}
export {Server}

// Warning: (ae-forgotten-export) The symbol "GenericRepository" needs to be exported by the entry point index.d.ts
//
// @public
export abstract class Service<
  Repository = GenericRepository,
> extends Bootstrapper<Repository> {
  constructor(app: Framework)
  // Warning: (ae-forgotten-export) The symbol "GenericClassMap" needs to be exported by the entry point index.d.ts
  bindClass<ClassMap = GenericClassMap>(
    properties: ClassMap,
  ): void
  // Warning: (ae-forgotten-export) The symbol "GenericFunctionMap" needs to be exported by the entry point index.d.ts
  bindMacro<FunctionMap = GenericFunctionMap>(
    properties: FunctionMap,
  ): void
  // @virtual
  boot?(app: Framework): any
  // @virtual
  booted?(app: Framework): any
  // @virtual
  bootstrap?(app: Framework): any
  // @virtual
  bootstrapped?(app: Framework): any
  // @virtual
  register?(app: Framework): any
  // @virtual
  registered?(app: Framework): any
}

// @public @virtual
export interface Services
  extends Partial<Index<new (app: Framework) => Service>> {}

// @public
export class Store<T = Configuration> extends Service<T> {
  // @override (undocumented)
  get<T = any>(path: keyof Repository_2): T
  // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: No member was found with name "name"
  //
  // @override (undocumented)
  name: string
  // Warning: (ae-forgotten-export) The symbol "Repository" needs to be exported by the entry point index.d.ts
  repository: Repository_2
}

// @public
export interface Tapable<P extends any[] = [Framework], T = any>
  extends Factory<[P], T> {}

// @public
interface Target {
  // (undocumented)
  host: string
  // (undocumented)
  port: number
}

// @public @deprecated
export interface WebpackPlugin<P = any, O = any>
  extends Extension.CompilerPlugin<
    Extension.ApplyPlugin,
    unknown
  > {}

// Warnings were encountered during analysis:
//
// src/Configuration.ts:211:7 - (ae-forgotten-export) The symbol "TermColor" needs to be exported by the entry point index.d.ts
```
