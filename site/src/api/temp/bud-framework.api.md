## API Report File for "@roots/bud-framework"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="node" />

import type { Application } from 'express';
import type { Class } from 'type-fest';
import { Compiler as Compiler_2 } from 'webpack';
import { Configuration as Configuration_2 } from 'webpack';
import { Container } from '@roots/container';
import type * as DevMiddleware from 'webpack-dev-middleware';
import type { Handler } from 'express';
import type { Instance } from 'ink';
import { MultiCompiler } from 'webpack';
import { ProgressPlugin } from 'webpack';
import type * as Proxy_2 from 'http-proxy-middleware';
import type { Server as Server_2 } from 'http';
import { Signale } from 'signale';
import { StatsCompilation } from 'webpack';
import { StatsError } from 'webpack';
import type { WatchOptions } from 'chokidar';
import * as Webpack from 'webpack';

// @public
abstract class Abstract extends Service implements Cache_2.Interface {
    abstract buildDependencies(): string[];
    abstract directory(): string;
    abstract hash(): string;
    abstract version(): string;
}

// @public
abstract class Abstract_2 extends Service<Peers.Repository> {
    abstract getProjectInfo(): {
        [key: string]: any;
    };
    abstract hasPeerDependency(pkg: string): boolean;
    abstract peers: Peers.Interface;
    resolveFrom: string[];
}

// @public
abstract class Abstract_3 implements Peers.Interface {
    abstract discover(type: 'dependencies' | 'devDependencies'): this;
    abstract getPeerManifest(name: string): {
        [key: string]: any;
    };
    abstract install(): void;
    abstract isExtension(name: string): boolean;
    abstract project: Project.Interface;
    abstract registerDiscovered(): void;
    abstract resolvePeerByName(name: string): string;
}

// Warning: (ae-internal-mixed-release-tag) Mixed release tags are not allowed for "access" because one of its declarations is marked as @internal
//
// @public
export function access<I = any>(this: Framework, value: Framework.Tapable | I): any;

// @internal (undocumented)
export interface access<I = any> {
    // (undocumented)
    (this: Framework, value: Framework.Tapable | I): I;
}

// @public
export interface Api extends Service {
}

// Warning: (ae-internal-mixed-release-tag) Mixed release tags are not allowed for "bootstrap" because one of its declarations is marked as @internal
//
// @public
export function bootstrap(this: Framework): Framework;

// @internal
export interface bootstrap {
    // (undocumented)
    (this: Framework): Framework;
}

// @public
export abstract class Bootstrapper<T = any> extends Container<T> {
    constructor(app: Framework);
    get app(): Framework;
    name: any;
}

// @public
export interface Build extends Service {
    config: Webpack.Configuration;
    items: Build.Items;
    loaders: Build.Loaders;
    rebuild(): Webpack.Configuration;
    rules: Build.Rules;
}

// @public
export namespace Build {
    export interface Item {
        make(app: Framework): Build.Item.Output;
        mergeOptions(options: Build.Item.Options, app: Framework): void;
        setLoader(loader: (app?: Framework) => Build.Loader): void;
        setOptions(options: Build.Item.OptionsFn): void;
    }
    // (undocumented)
    export namespace Item {
        // (undocumented)
        export interface ConstructorOptions {
            // (undocumented)
            loader: Loader | LoaderFn;
            // (undocumented)
            options?: OptionsFn | Options;
        }
        // (undocumented)
        export type LoaderFn = (app?: Framework) => Loader;
        // (undocumented)
        export type Options = {
            [key: string]: any;
        };
        // (undocumented)
        export type OptionsFn = (app?: Framework) => Options;
        // (undocumented)
        export interface Output {
            // (undocumented)
            loader: Build.Loader.Output;
            // (undocumented)
            options?: {
                [key: string]: any;
            };
        }
    }
    export interface Items extends Framework.Index<Item> {
        // (undocumented)
        [key: string]: Item;
    }
    export interface Loader {
        make(app: Framework): string;
    }
    // (undocumented)
    export namespace Loader {
        // (undocumented)
        export type Input = Src | Output;
        // (undocumented)
        export type Output = string;
        // (undocumented)
        export type Src = (app?: Framework) => Output;
    }
    export interface Loaders extends Framework.Index<Loader> {
        // (undocumented)
        [key: string]: Loader;
    }
    export interface Rule {
        getExclude(app: Framework): Rule.Output['exclude'];
        getGenerator(app: Framework): any;
        getParser(app: Framework): Rule.Parser;
        getTest(app: Framework): RegExp;
        getType(app: Framework): Rule.Output['type'];
        getUse(app: Framework): Item[];
        make(app: Framework): Rule.Output | Webpack.RuleSetRule;
        setExclude(exclude: Rule.ExcludeFn | RegExp): void;
        setGenerator(Generator: any | Rule.GeneratorFn): void;
        setParser(parser: Rule.Parser | Rule.ParserFn): void;
        setTest(test: RegExp | Rule.TestFn): void;
        setType(type: string | Rule.TypeFn): void;
        setUse(use: Rule.UseFn): void;
        test?: (app?: Framework) => Webpack.RuleSetRule['test'];
        use?: (app?: Framework) => Item[];
    }
    // (undocumented)
    export namespace Rule {
        // (undocumented)
        export type ExcludeFn = (app?: Framework) => RegExp;
        // (undocumented)
        export type GeneratorFn = (app?: Framework) => any;
        export interface Options {
            // (undocumented)
            exclude?: RegExp | ExcludeFn;
            // (undocumented)
            generator?: GeneratorFn | any;
            // (undocumented)
            parser?: ParserFn | Parser;
            // (undocumented)
            test: RegExp | TestFn;
            // (undocumented)
            type?: string | TypeFn;
            // (undocumented)
            use?: Item[] | UseFn;
        }
        export interface Output {
            // (undocumented)
            exclude?: RegExp;
            // (undocumented)
            generator?: any;
            // (undocumented)
            parser?: Parser;
            // (undocumented)
            test: RegExp;
            // (undocumented)
            type?: string;
            // (undocumented)
            use?: {
                loader: string;
                options?: {
                    [key: string]: any;
                };
            }[];
        }
        // (undocumented)
        export interface Parser {
            // (undocumented)
            parse: (input?: string) => any;
        }
        // (undocumented)
        export type ParserFn = (app?: Framework) => Parser;
        // (undocumented)
        export type TestFn = (app?: Framework) => RegExp;
        // (undocumented)
        export type TypeFn = (app?: Framework) => string;
        // (undocumented)
        export type UseFn = (app?: Framework) => Item[];
    }
    export interface Rules extends Framework.Index<Rule> {
        // (undocumented)
        [key: string]: Rule;
    }
}

declare namespace Cache_2 {
    export {
        Interface,
        Abstract
    }
}
export { Cache_2 as Cache }

// @public
function close_2(this: Framework, done?: (code?: number) => never): void;

// @public
interface close_2 {
    // (undocumented)
    (this: Framework, done?: CallableFunction): void;
}
export { close_2 as close }

// Warning: (ae-internal-mixed-release-tag) Mixed release tags are not allowed for "Compiler" because one of its declarations is marked as @internal
//
// @public
export interface Compiler extends Service {
    before(): any;
    callback(err: StatsError, stats: StatsCompilation): void;
    compile(): Compiler.Instance;
    instance: Compiler.Instance;
    isCompiled: boolean;
    progress: Compiler.Progress;
    stats: StatsCompilation;
}

// @internal
export namespace Compiler {
    // (undocumented)
    export type Config = Configuration_2;
    // (undocumented)
    export type Instance = Compiler_2 | MultiCompiler;
    // (undocumented)
    export type Progress = any;
    // (undocumented)
    export namespace Progress {
        // (undocumented)
        export type Handler = ProgressPlugin['handler'];
    }
}

// @public
export interface Configuration {
    build: Partial<Webpack.Configuration>;
    clean: boolean;
    cli: boolean;
    debug: boolean;
    discover: boolean;
    extension: {
        [key: string]: any;
    };
    fileFormat: string;
    hash: boolean;
    hashFormat: string;
    html: boolean;
    install: boolean;
    location: Framework.Locations;
    log: boolean;
    manifest: boolean;
    minimize: boolean;
    name: string;
    patterns: {
        [key: string]: RegExp;
    };
    server: Server.Configuration;
    theme: {
        spacing: number;
        colors: {
            foreground: Configuration.TermColor;
            faded: Configuration.TermColor;
            primary: Configuration.TermColor;
            primaryAlt: Configuration.TermColor;
            error: Configuration.TermColor;
            errorAlt: Configuration.TermColor;
            warning: Configuration.TermColor;
            success: Configuration.TermColor;
            accent: Configuration.TermColor;
            flavor: Configuration.TermColor;
        };
        screens: [
        [
        number,
        number
        ],
        [
        number,
        number
        ],
        [
        number,
        number
        ],
        [
        number,
        number
        ]
        ];
        columns: number;
        maxWidth: number;
        maxHeight: number;
    };
}

// @public
export namespace Configuration {
    export type TermColor = `#${string}` | `black` | `red` | `green` | `yellow` | `blue` | `magenta` | `cyan` | `white` | `gray` | `grey` | `blackBright` | `redBright` | `greenBright` | `yellowBright` | `blueBright` | `magentaBright` | `cyanBright` | `whiteBright`;
}

// Warning: (ae-internal-mixed-release-tag) Mixed release tags are not allowed for "container" because one of its declarations is marked as @internal
//
// @internal
export interface container<T = any> {
    // (undocumented)
    <T>(repository?: T): Container<T>;
}

// @public
export const container: <T = any>(repository?: T) => Container<T>;

// @public
export interface Dashboard extends Service {
    instance: Instance;
    render(Component: any, title?: string): void;
    renderError(body: string, title: string): void;
    run(): void;
}

// @public
export interface Dependencies extends Service {
    install(dependencies: {
        name: string;
        ver: string;
        source: string;
        type: 'dependencies' | 'devDependencies';
    }[]): void;
    messages: Container;
    overrideInstallTarget(dep: string, type: 'dependencies' | 'devDependencies'): boolean;
}

// @public
export interface Env extends Container {
    getPublicEnv(): Framework.Index<any>;
}

// @public
export interface Extension {
    app: Framework;
    apply: WebpackPlugin['apply'];
    boot(): Extension;
    get(key: `${keyof Framework.Extensions & string}`): any;
    make: Module['make'] | WebpackPlugin['make'];
    makeKey(key: `${keyof Framework.Extensions & string}`): Hooks.Name;
    module: Module | WebpackPlugin;
    name: Module['name'] | WebpackPlugin['options'];
    options: Module['options'] | WebpackPlugin['options'];
    register(): Extension;
    set(key: `${keyof Framework.Extensions & string}`, value: any): void;
    when: Module['when'];
}

// @public
export interface Extensions extends Service<Partial<Framework.Extensions>> {
    add(extension: Module | WebpackPlugin): void;
    getEligibleWebpackModules(): (Module | WebpackPlugin)[];
    make(): PluginInstance[];
}

// Warning: (ae-internal-mixed-release-tag) Mixed release tags are not allowed for "Framework" because one of its declarations is marked as @internal
//
// @public
export abstract class Framework {
    constructor(options: Framework.Options);
    access: access;
    api: Api;
    bindMethod<T = Function>(key: string, method: T & Function): Framework;
    bootstrap: bootstrap;
    build: Build;
    cache: Cache_2.Interface;
    children: Container<Framework.Instances> | null;
    close: close_2;
    compiler: Compiler;
    container: container;
    dashboard: Dashboard;
    debug(message?: any, ...optionalArgs: any[]): void;
    dependencies: Dependencies;
    env: Env;
    error(message?: any, ...optionalArgs: any[]): void;
    extensions: Extensions;
    get: get;
    get hasChildren(): boolean;
    hooks: Hooks;
    abstract implementation: Framework.Constructor;
    info(message?: any, ...optionalArgs: any[]): void;
    get isDevelopment(): boolean;
    get isParent(): boolean;
    get isProduction(): boolean;
    log(message?: any, ...optionalArgs: any[]): void;
    logger: Logger;
    make: make;
    mode: Framework.Mode;
    name: string;
    parent: Framework | null;
    path: path;
    pipe: pipe;
    project: Project.Interface;
    sequence: typeof sequence;
    server: Server;
    services: Framework.Services;
    setPath: setPath;
    store: Store;
    success(message?: any, ...optionalArgs: any[]): void;
    tap: tap;
    warn(message?: any, ...optionalArgs: any[]): void;
    when: when;
}

// @internal
export namespace Framework {
    export type Constructor = new (options: Options) => Framework;
    export interface Extensions extends Partial<Index<Module | WebpackPlugin>> {
    }
    export type Index<T = any> = {
        [key: string]: T;
    };
    export interface Instances extends Index<Framework> {
    }
    export interface Items extends Framework.Index<Build.Item> {
    }
    export interface Loaders extends Framework.Index<Build.Loader> {
    }
    export interface Locations extends Framework.Index<string> {
        // (undocumented)
        dist: string;
        // (undocumented)
        modules: string;
        // (undocumented)
        project: string;
        // (undocumented)
        publicPath: string;
        // (undocumented)
        src: string;
        // (undocumented)
        storage: string;
    }
    export type Mode = 'production' | 'development';
    // (undocumented)
    export interface Options {
        // @public
        config?: Configuration;
        // @public
        mode?: Framework.Mode;
        name: string;
        parent?: Framework;
        // @public
        services?: Framework.Services;
    }
    export interface Rules extends Framework.Index<Build.Rule> {
    }
    export interface Services extends Index<new (app: Framework) => Service> {
    }
    // @public
    export interface Tapable<T = Framework> {
        // (undocumented)
        (value?: T): any;
    }
}

// Warning: (ae-internal-mixed-release-tag) Mixed release tags are not allowed for "get" because one of its declarations is marked as @internal
//
// @internal
export interface get {
    // (undocumented)
    (this: Framework, name: string, tap?: (app: Framework) => Framework): Framework;
}

// @internal @override
export interface get {
    // (undocumented)
    (name: string, tap?: (app: Framework) => Framework): Framework;
}

// @public
export const get: get;

// @public
export interface Hooks extends Service<Hooks.Repository> {
    filter<T = any>(id: Hooks.Name, seed?: any): T;
    on(id: Hooks.Name, callback: Hooks.Hook): Framework;
}

// @public
export namespace Hooks {
    // (undocumented)
    export namespace BuildHooks {
        // (undocumented)
        export interface Config extends Webpack.Configuration {
            // (undocumented)
            mode?: Framework.Mode;
            // (undocumented)
            module?: {
                noParse?: RegExp | RegExp[] | ((content: string) => boolean);
                parser: any;
                rules?: RulesOverride;
            };
            // (undocumented)
            optimization?: OptimizationOverride;
            // (undocumented)
            parallelism?: Webpack.Configuration['parallelism'];
        }
        // (undocumented)
        export type Dive<T, S> = {
            [K in keyof T as `build/${S & string}/${K & string}`]: T[K];
        };
        // (undocumented)
        export type Keys = `build` | `build/${keyof Config}` | keyof Dive<Config['output'], 'output'> | 'build/output/pathInfo' | keyof Dive<Config['module'], 'module'> | keyof Dive<Config['module']['rules'], 'module/rules'> | keyof Dive<Config['module']['rules']['oneOf'], 'module/rules/oneOf'> | 'build/module/rules/parser' | keyof Dive<Config['resolve'], 'resolve'> | keyof Dive<Config['resolveLoader'], 'resolveLoader'> | 'build/cache/name' | 'build/cache/cacheLocation' | 'build/cache/cacheDirectory' | 'build/cache/hashAlgorithm' | 'build/cache/managedPaths' | 'build/cache/version' | 'build/cache/type' | 'build/cache/buildDependencies' | keyof Dive<Config['experiments'], 'experiments'> | keyof Dive<Config['watchOptions'], 'watchOptions'> | keyof Dive<Config['performance'], 'performance'> | keyof Dive<Config['optimization'], 'optimization'> | keyof Dive<Config['optimization']['splitChunks'], 'optimization/splitChunks'> | keyof Dive<Config['optimization']['splitChunks']['cacheGroups'], 'optimization/splitChunks/cacheGroups'> | keyof Dive<Config['optimization']['splitChunks']['cacheGroups']['vendor'], 'optimization/splitChunks/cacheGroups/vendor'>;
        // (undocumented)
        export type Optimization = Webpack.Configuration['optimization'];
        // (undocumented)
        export interface OptimizationOverride extends Optimization {
            // (undocumented)
            splitChunks: {
                cacheGroups: any;
            };
        }
        // (undocumented)
        export type Rules = Webpack.Configuration['module']['rules'];
        // (undocumented)
        export interface RulesOverride extends Rules {
            // (undocumented)
            oneOf: Webpack.RuleSetRule;
        }
            {};
    }
    export namespace Extension {
        // (undocumented)
        export type Keys = keyof {
            [K in keyof Framework.Extensions as `extension` | `extension/${K}` | `extension/${K}/${`${keyof Module & string}` | `${keyof Module & string}/${string}`}`]: Module | WebpackPlugin;
        };
    }
    export type Hook<T = any> = ((value?: T) => T) | T;
    // (undocumented)
    export type ItemKeys = `item` | `item/${keyof Build.Items}` | `item/${keyof Build.Items}/loader` | `item/${keyof Build.Items}/options` | `item/${keyof Build.Items}/options/${string}`;
    // (undocumented)
    export type Key = `${keyof Repository}`;
    // (undocumented)
    export type LoaderKeys = `loader` | `loader/${keyof Build.Loaders}`;
    // (undocumented)
    export type LocationKeys = `location/${keyof Framework.Locations & string}`;
    // @internal (undocumented)
    export type Name = `before` | `after` | `done` | `${ItemKeys}` | `${LocationKeys}` | `${LoaderKeys}` | `${RuleKeys}` | `${Extension.Keys}` | `${BuildHooks.Keys}`;
    // Warning: (ae-incompatible-release-tags) The symbol "Repository" is marked as @public, but its signature references "Name" which is marked as @internal
    export type Repository = {
        [K in Name as `${K & string}`]?: Hook[];
    };
    // (undocumented)
    export type RuleKeys = `rule` | `rule/${keyof Build.Rules}` | `rule/${keyof Build.Rules}/${keyof Webpack.RuleSetRule}` | `rule/${keyof Build.Rules}/${keyof Webpack.RuleSetRule & `options`}/${string}`;
        {};
}

// @public
interface Interface {
    buildDependencies(): string[];
    directory(): string;
    hash(): string;
    version(): string;
}

// @public
interface Interface_2 {
    discover(type: 'dependencies' | 'devDependencies'): this;
    getPeerManifest(name: string): {
        [key: string]: any;
    };
    install(): void;
    isExtension(name: string): boolean;
    project: Project.Interface;
    registerDiscovered(): void;
    registerDiscovered(): void;
    resolvePeerByName(name: string): string;
}

// @public
interface Interface_3 extends Service {
    getProjectInfo(): {
        [key: string]: any;
    };
    hasPeerDependency(pkg: string): boolean;
    peers: Peers.Interface;
    resolveFrom: string[];
}

// @public
export interface Logger extends Service {
    instance: Signale;
    // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: No member was found with name "name"
    //
    // (undocumented)
    name: 'logger';
}

// Warning: (ae-internal-mixed-release-tag) Mixed release tags are not allowed for "make" because one of its declarations is marked as @internal
//
// @public
export function make(name: string, tap?: Framework.Tapable): Framework;

// @internal
export interface make {
    // (undocumented)
    (name: string, tap?: Framework.Tapable): Framework;
}

// Warning: (ae-internal-mixed-release-tag) Mixed release tags are not allowed for "Module" because one of its declarations is marked as @internal
//
// @public
export interface Module<Plugin = any, Options = any> {
    api?: Module.Api;
    // @deprecated
    apply?: CallableFunction;
    boot?: Module.Boot;
    // @deprecated
    make?: Module.Make<Plugin, Options>;
    name?: Module.Name;
    options?: Module.Options<Options>;
    register?: Module.Register;
    when?: Module.When<Options>;
}

// @internal
export namespace Module {
    // (undocumented)
    export type Api = ((app: Framework) => {
        [key: string]: any;
    }) | {
        [key: string]: any;
    };
    // (undocumented)
    export type Boot = (app: Framework) => any;
    // (undocumented)
    export type Config = (app: Framework) => any;
    // (undocumented)
    export type Make<Plugin = any, Opts = any> = (options?: Container<Opts>, app?: Framework) => Plugin;
    // (undocumented)
    export type Name = keyof Framework.Extensions;
    // (undocumented)
    export type Options<T = any> = T | ((app: Framework) => T);
    // (undocumented)
    export type Register = (app: Framework) => any;
    // (undocumented)
    export type When<T = any> = ((app: Framework, opt?: Container<T>) => boolean) | boolean;
}

// @public (undocumented)
export interface path {
    // (undocumented)
    (this: Framework, key: keyof Framework.Locations & string, ...path: string[]): string;
}

// @public (undocumented)
export interface path {
    // (undocumented)
    (key: keyof Framework.Locations & string, ...path: string[]): string;
}

// @public (undocumented)
export const path: path;

// @public
interface Peer {
    name: string;
    source: string;
    type: 'dependencies' | 'devDependencies';
    ver: string;
}

declare namespace Peers {
    export {
        Peer,
        Repository,
        Abstract_3 as Abstract,
        Interface_2 as Interface
    }
}
export { Peers }

// Warning: (ae-forgotten-export) The symbol "Callback" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function pipe<T = Framework>(fns: Callback<T>[], value?: T): T;

// @public (undocumented)
export interface pipe {
    // (undocumented)
    <T = Framework>(fns: Callback<T>[], value?: T): T;
}

// @public
export interface PluginInstance {
    apply: CallableFunction;
}

declare namespace Project {
    export {
        Abstract_2 as Abstract,
        Interface_3 as Interface
    }
}
export { Project }

// @public
interface Repository {
    dependencies: {
        [key: string]: string;
    };
    devDependencies: {
        [key: string]: string;
    };
    extensions: {
        [key: string]: Peer;
    };
    name: string;
    peers: {
        [key: string]: Peer;
    };
}

// Warning: (ae-forgotten-export) The symbol "Callback" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function sequence<T = Framework>(this: Framework, fns: Callback_2[], value?: T): Framework;

// @public (undocumented)
export interface sequence {
    // (undocumented)
    <T = Framework>(this: Framework, fns: Callback_2[], value?: T): Framework;
}

// Warning: (ae-internal-mixed-release-tag) Mixed release tags are not allowed for "Server" because one of its declarations is marked as @internal
//
// @public
export interface Server extends Service {
    application: Server.Application;
    assets: string[];
    close(): void;
    config: Server.Config;
    getWatchedFilesArray(): string[];
    inject(): void;
    instance: Server.Instance;
    isWatchable: boolean;
    middleware: Server.Middleware.Inventory;
    run(): this;
    watcher: {
        [key: string]: any;
        close: CallableFunction;
        on: CallableFunction;
    };
}

// @internal (undocumented)
export namespace Server {
    export type Application = Application;
    export type Compiler = Webpack.Compiler | Webpack.MultiCompiler;
    export type Config = Container<Configuration>;
    export interface Configuration {
        browser?: {
            log?: boolean;
            indicator?: boolean;
            overlay?: boolean;
        };
        disableHostCheck?: DevMiddleware.Options[];
        filename?: string;
        headers?: DevMiddleware.Options['headers'];
        host?: string;
        index?: DevMiddleware.Options['index'];
        methods?: DevMiddleware.Options['methods'];
        middleware?: {
            [key: string]: boolean;
        };
        mimeTypes?: DevMiddleware.MimeTypeMap;
        port?: number;
        proxy?: {
            host?: string;
            port?: number;
        };
        publicPath?: DevMiddleware.Options['publicPath'];
        watch?: {
            files: string[];
            options: WatchOptions;
        };
    }
    export type Instance = Server_2;
    export type Middleware = any;
    // (undocumented)
    export namespace Middleware {
        // (undocumented)
        export type Init = (options: Options) => Middleware;
        // (undocumented)
        export interface Inventory {
            // (undocumented)
            [key: string]: Middleware;
        }
        // (undocumented)
        export interface Options {
            // (undocumented)
            compiler: Compiler;
            // (undocumented)
            config: Config;
        }
        // (undocumented)
        export type Proxy = Proxy_2.RequestHandler & Handler;
        // (undocumented)
        export interface Target {
            // (undocumented)
            host: string;
            // (undocumented)
            port: number;
        }
    }
}

// Warning: (ae-forgotten-export) The symbol "GenericRepository" needs to be exported by the entry point index.d.ts
//
// @public
export abstract class Service<Repository = GenericRepository> extends Bootstrapper<Repository> {
    constructor(app: Framework);
    // Warning: (ae-forgotten-export) The symbol "GenericClassMap" needs to be exported by the entry point index.d.ts
    bindClass<ClassMap = GenericClassMap>(properties: ClassMap): void;
    // Warning: (ae-forgotten-export) The symbol "GenericFunctionMap" needs to be exported by the entry point index.d.ts
    bindMacro<FunctionMap = GenericFunctionMap>(properties: FunctionMap): void;
    // @virtual
    boot?(app: Framework): any;
    // @virtual
    booted?(app: Framework): any;
    // @virtual
    bootstrap?(app: Framework): any;
    // @virtual
    bootstrapped?(app: Framework): any;
    // @virtual
    register?(app: Framework): any;
    // @virtual
    registered?(app: Framework): any;
}

// Warning: (ae-internal-mixed-release-tag) Mixed release tags are not allowed for "setPath" because one of its declarations is marked as @internal
//
// @public
export function setPath(this: Framework, ...args: any[]): Framework;

// @internal
export interface setPath {
    // (undocumented)
    (this: Framework, ...args: any[]): Framework;
}

// Warning: (ae-internal-mixed-release-tag) Mixed release tags are not allowed for "Store" because one of its declarations is marked as @internal
//
// @public
export class Store<T = Configuration> extends Service<T> {
    // @override (undocumented)
    get<T = any>(path: keyof Store.Repository): T;
    // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: No member was found with name "name"
    //
    // (undocumented)
    name: string;
}

// @internal (undocumented)
export namespace Store {
    // (undocumented)
    export type Keys = `${keyof Configuration & string}` | `theme.${keyof Configuration['theme'] & string}` | `theme.screens` | `theme.colors.${keyof Configuration['theme']['colors'] & string}` | `server.${keyof Configuration['server'] & string}` | `server.middleware.${keyof Configuration['server']['middleware'] & string}` | `server.browser.${keyof Configuration['server']['browser'] & string}` | `server.${keyof Configuration['server'] & string}.${string}` | `env.${string}` | `location.${keyof Configuration['location'] & string}` | `patterns.${keyof Configuration['patterns'] & string}` | `build.${keyof Webpack.Configuration}` | `build.module.${keyof Webpack.Configuration['module']}` | `build.module.${keyof Webpack.Configuration['module']}.${string}` | `extension.${string}` | `build.${keyof Webpack.Configuration}.${string}`;
    // (undocumented)
    export type Repository = {
        [K in Store.Keys & string]?: any;
    };
}

// @public (undocumented)
export interface tap<T = Framework> {
    // (undocumented)
    (fn: Framework.Tapable<T>, bound?: boolean): T;
}

// @public (undocumented)
export const tap: tap<Framework>;

// @public
export interface WebpackPlugin<ApplyConstructor = {
    apply: any;
}, Options = any> extends Module {
    apply?: CallableFunction;
    make?: Module.Make<ApplyConstructor & {
        apply: any;
    }, Options>;
    when?: Module.When<Options>;
}

// @public (undocumented)
export function when(this: Framework, test: ((app: Framework) => boolean) | boolean, trueCase: (app: Framework) => any, falseCase?: (app: Framework) => any): Framework;

// @public (undocumented)
export interface when {
    // (undocumented)
    (this: Framework, test: ((app: Framework) => boolean) | boolean, trueCase: (app: Framework) => any, falseCase?: (app: Framework) => any): Framework;
}

```
