## API Report File for "@roots/bud-framework"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="node" />

import { Application } from 'express';
import { Class } from 'type-fest';
import { Compiler as Compiler_2 } from 'webpack';
import { Configuration as Configuration_2 } from 'webpack';
import { Container } from '@roots/container';
import * as DevMiddleware from 'webpack-dev-middleware';
import { Handler } from 'express';
import { Instance } from 'ink';
import { MultiCompiler } from 'webpack';
import { ProgressPlugin } from 'webpack';
import * as Proxy_2 from 'http-proxy-middleware';
import { RuleSetRule } from 'webpack';
import { Server as Server_2 } from 'http';
import { Signale } from 'signale';
import { StatsCompilation } from 'webpack';
import { StatsError } from 'webpack';
import { WatchOptions } from 'chokidar';
import * as Webpack from 'webpack';

// @public
abstract class Abstract extends Service implements Cache_2.Interface {
    abstract buildDependencies(): string[];
    abstract directory(): string;
    abstract hash(): string;
    abstract version(): string;
}

// @public
abstract class Abstract_2 extends Service<Peers.Repository> {
    abstract getProjectInfo(): {
        [key: string]: any;
    };
    abstract hasPeerDependency(pkg: string): boolean;
    abstract peers: Peers.Interface;
    resolveFrom: string[];
}

// @public
abstract class Abstract_3 implements Peers.Interface {
    abstract discover(type: 'dependencies' | 'devDependencies'): this;
    abstract getPeerManifest(name: string): {
        [key: string]: any;
    };
    abstract install(): void;
    abstract isExtension(name: string): boolean;
    abstract project: Project.Interface;
    abstract registerDiscovered(): void;
    abstract resolvePeerByName(name: string): string;
}

// Warning: (ae-internal-mixed-release-tag) Mixed release tags are not allowed for "access" because one of its declarations is marked as @internal
//
// @public
export function access<I = any>(this: Framework, value: Tapable | I): any;

// @internal (undocumented)
export interface access<I = any> {
    // (undocumented)
    (this: Framework, value: Tapable | I): I;
}

// @public
export interface Api extends Service {
}

// @public
interface ApplyPlugin extends Loose {
    // (undocumented)
    apply(...args: any[]): unknown;
}

// @public
export type AtLeastOne<Type = unknown> = Type | Type[];

// Warning: (ae-internal-mixed-release-tag) Mixed release tags are not allowed for "bootstrap" because one of its declarations is marked as @internal
//
// @public
export function bootstrap(this: Framework): Framework;

// @internal
export interface bootstrap {
    // (undocumented)
    (this: Framework): Framework;
}

// @public
export abstract class Bootstrapper<T = any> extends Container<T> {
    constructor(app: Framework);
    get app(): Framework;
    name: any;
}

declare namespace Build {
    export {
        Build_2 as Interface,
        Build_3 as Abstract
    }
}
export { Build }

// @public
interface Build_2 extends Service {
    config: Webpack.Configuration;
    items: Items;
    loaders: Loaders;
    rebuild(): Webpack.Configuration;
    rules: Rules;
}

// @public
class Build_3 extends Service {
    config: Webpack.Configuration;
    items: Item.Interface[];
    loaders: Loader.Interface[];
    rules: Rule.Interface[];
}

declare namespace Cache_2 {
    export {
        Interface,
        Abstract
    }
}
export { Cache_2 as Cache }

// @public
function close_2(this: Framework, done?: (code?: number) => never): void;

// @public
interface close_2 {
    // (undocumented)
    (this: Framework, done?: CallableFunction): void;
}
export { close_2 as close }

// Warning: (ae-internal-mixed-release-tag) Mixed release tags are not allowed for "Compiler" because one of its declarations is marked as @internal
//
// @public
export interface Compiler extends Service {
    before(): any;
    callback(err: StatsError, stats: StatsCompilation): void;
    compile(): Compiler.Instance;
    instance: Compiler.Instance;
    isCompiled: boolean;
    progress: Compiler.Progress;
    stats: StatsCompilation;
}

// @internal
export namespace Compiler {
    // (undocumented)
    export type Config = Configuration_2;
    // (undocumented)
    export type Instance = Compiler_2 | MultiCompiler;
    // (undocumented)
    export type Progress = any;
    // (undocumented)
    export namespace Progress {
        // (undocumented)
        export type Handler = ProgressPlugin['handler'];
    }
}

// @public
interface CompilerPlugin<Plugin = ApplyPlugin, Options = unknown> extends Module_2 {
    apply?: Plugin & ApplyPlugin['apply'];
    make?: Maybe<[
    Container<Options>,
    Framework
    ], Plugin & ApplyPlugin>;
    // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: No member was found with name "name"
    //
    // (undocumented)
    name: Module_2['name'];
    // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: No member was found with name "options"
    //
    // (undocumented)
    options?: Maybe<[Framework], Options>;
    // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: No member was found with name "when"
    //
    // (undocumented)
    when?: Module_2['when'];
}

// @public
export interface Configuration {
    build: Partial<Webpack.Configuration>;
    clean: boolean;
    cli: boolean;
    debug: boolean;
    discover: boolean;
    extension: Index<any>;
    fileFormat: string;
    hash: boolean;
    hashFormat: string;
    html: boolean;
    install: boolean;
    location: Locations;
    log: boolean;
    manifest: boolean;
    minimize: boolean;
    name: string;
    patterns: Index<RegExp>;
    server: Server.Configuration;
    theme: {
        spacing: number;
        colors: {
            foreground: TermColor;
            faded: TermColor;
            primary: TermColor;
            primaryAlt: TermColor;
            error: TermColor;
            errorAlt: TermColor;
            warning: TermColor;
            success: TermColor;
            accent: TermColor;
            flavor: TermColor;
        };
        screens: [
        [
        number,
        number
        ],
        [
        number,
        number
        ],
        [
        number,
        number
        ],
        [
        number,
        number
        ]
        ];
        columns: number;
        maxWidth: number;
        maxHeight: number;
    };
}

// @public
export type Constructor = new (options: Options) => Framework;

// @public
interface ConstructorOptions {
    loader: Maybe<[Framework], Loader.Interface>;
    options?: Maybe<[Framework], Options_2>;
}

// Warning: (ae-internal-mixed-release-tag) Mixed release tags are not allowed for "container" because one of its declarations is marked as @internal
//
// @internal
export interface container<T = any> {
    // (undocumented)
    <T>(repository?: T): Container<T>;
}

// @public
export const container: <T = any>(repository?: T) => Container<T>;

// @public
interface Controller {
    app: Framework;
    apply: Extension_2['apply'];
    boot(): Controller;
    get(key: Name): any;
    make: Extension_2['make'];
    makeKey(key: Name): Hooks.Name;
    // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: This type of declaration is not supported yet by the resolver
    //
    // (undocumented)
    module: Extension_2;
    // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: This type of declaration is not supported yet by the resolver
    //
    // (undocumented)
    name: Extension_2['name'];
    // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: This type of declaration is not supported yet by the resolver
    //
    // (undocumented)
    options: Extension_2['options'];
    register(): Controller;
    set(key: Name, value: any): void;
    // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: This type of declaration is not supported yet by the resolver
    //
    // (undocumented)
    when: Extension_2['when'];
}

// @public
export interface Dashboard extends Service {
    instance: Instance;
    render(Component: any, title?: string): void;
    renderError(body: string, title: string): void;
    run(): void;
}

// @public
export interface Dependencies extends Service {
    install(dependencies: {
        name: string;
        ver: string;
        source: string;
        type: 'dependencies' | 'devDependencies';
    }[]): void;
    messages: Container;
    overrideInstallTarget(dep: string, type: 'dependencies' | 'devDependencies'): boolean;
}

// @public
export interface Env extends Container {
    getPublicEnv(): Index<any>;
}

declare namespace Extension {
    export {
        Name,
        Extension_2 as Extension,
        ApplyPlugin,
        CompilerPlugin,
        Controller,
        Module_2 as Module
    }
}
export { Extension }

// @public
type Extension_2<P = ApplyPlugin, O = unknown> = Module_2<O> | CompilerPlugin<P, O>;

// @public
export interface Extensions extends Service<Partial<Plugins | Modules>> {
    add(extension: Extension_2): void;
    getEligibleWebpackModules(): Extension_2[];
    make(): ApplyPlugin[];
}

// @public
export interface Factory<P extends any[], T> {
    // (undocumented)
    (...args: P): T;
}

// @public
interface Factory_2 {
    // (undocumented)
    (app: Framework): LoaderInterface;
}

// @public
export abstract class Framework {
    constructor(options: Options);
    access: access;
    api: Api;
    bindMethod<T = Function>(key: string, method: T & Function): Framework;
    // (undocumented)
    bootstrap: bootstrap;
    // (undocumented)
    build: Build.Interface;
    cache: Cache_2.Interface;
    children: Container<Index<Framework>>;
    close: close_2;
    compiler: Compiler;
    container: container;
    dashboard: Dashboard;
    debug(message?: any, ...optionalArgs: any[]): void;
    dependencies: Dependencies;
    env: Env;
    error(message?: any, ...optionalArgs: any[]): void;
    extensions: Extensions;
    get: get;
    get hasChildren(): boolean;
    hooks: Hooks;
    abstract implementation: Constructor;
    info(message?: any, ...optionalArgs: any[]): void;
    get isDevelopment(): boolean;
    get isParent(): boolean;
    get isProduction(): boolean;
    log(message?: any, ...optionalArgs: any[]): void;
    logger: Logger;
    // (undocumented)
    make: make;
    mode: Mode;
    name: string;
    parent: Framework | null;
    path: path;
    pipe: pipe;
    project: Project.Interface;
    sequence: typeof sequence;
    server: Server;
    services: Services;
    // (undocumented)
    setPath: setPath;
    store: Store;
    success(message?: any, ...optionalArgs: any[]): void;
    // (undocumented)
    tap: tap;
    warn(message?: any, ...optionalArgs: any[]): void;
    when: when;
}

// Warning: (ae-internal-mixed-release-tag) Mixed release tags are not allowed for "get" because one of its declarations is marked as @internal
//
// @internal
export interface get {
    // (undocumented)
    (this: Framework, name: string, tap?: (app: Framework) => Framework): Framework;
}

// @internal @override
export interface get {
    // (undocumented)
    (name: string, tap?: (app: Framework) => Framework): Framework;
}

// @public
export const get: get;

// @public
export interface Hooks extends Service<Hooks.Repository> {
    filter<T = any>(id: Hooks.Name, seed?: any): T;
    on(id: Hooks.Name, callback: Hooks.Hook): Framework;
}

// @public
export namespace Hooks {
    // (undocumented)
    export namespace BuildHooks {
        // (undocumented)
        export interface Config extends Webpack.Configuration {
            // (undocumented)
            mode?: Mode;
            // (undocumented)
            module?: {
                noParse?: RegExp | RegExp[] | ((content: string) => boolean);
                parser: any;
                rules?: RulesOverride;
            };
            // (undocumented)
            optimization?: OptimizationOverride;
            // (undocumented)
            parallelism?: Webpack.Configuration['parallelism'];
        }
        // (undocumented)
        export type Dive<T, S> = {
            [K in keyof T as `build/${S & string}/${K & string}`]: T[K];
        };
        // (undocumented)
        export type Keys = `build` | `build/${keyof Config}` | keyof Dive<Config['output'], 'output'> | 'build/output/pathInfo' | keyof Dive<Config['module'], 'module'> | keyof Dive<Config['module']['rules'], 'module/rules'> | keyof Dive<Config['module']['rules']['oneOf'], 'module/rules/oneOf'> | 'build/module/rules/parser' | keyof Dive<Config['resolve'], 'resolve'> | keyof Dive<Config['resolveLoader'], 'resolveLoader'> | 'build/cache/name' | 'build/cache/cacheLocation' | 'build/cache/cacheDirectory' | 'build/cache/hashAlgorithm' | 'build/cache/managedPaths' | 'build/cache/version' | 'build/cache/type' | 'build/cache/buildDependencies' | keyof Dive<Config['experiments'], 'experiments'> | keyof Dive<Config['watchOptions'], 'watchOptions'> | keyof Dive<Config['performance'], 'performance'> | keyof Dive<Config['optimization'], 'optimization'> | keyof Dive<Config['optimization']['splitChunks'], 'optimization/splitChunks'> | keyof Dive<Config['optimization']['splitChunks']['cacheGroups'], 'optimization/splitChunks/cacheGroups'> | keyof Dive<Config['optimization']['splitChunks']['cacheGroups']['vendor'], 'optimization/splitChunks/cacheGroups/vendor'>;
        // (undocumented)
        export type Optimization = Webpack.Configuration['optimization'];
        // (undocumented)
        export interface OptimizationOverride extends Optimization {
            // (undocumented)
            splitChunks: {
                cacheGroups: any;
            };
        }
        // (undocumented)
        export type Rules = Webpack.Configuration['module']['rules'];
        // (undocumented)
        export interface RulesOverride extends Rules {
            // (undocumented)
            oneOf: Webpack.RuleSetRule;
        }
            {};
    }
    export type Hook<T = any> = ((value?: T) => T) | T;
    // (undocumented)
    export type ItemKeys = `item` | `item/${keyof Items}` | `item/${keyof Items}/loader` | `item/${keyof Items}/options` | `item/${keyof Items}/options/${string}`;
    // (undocumented)
    export type Key = `${keyof Repository}`;
    export type Keys = keyof {
        [K in keyof Modules | keyof Plugins as `extension` | `extension/${K}` | `extension/${K}/${`${keyof Modules | keyof Plugins}` | (`${keyof Modules | keyof Plugins}/${string}` & string)}`]: Extension_2;
    };
    // (undocumented)
    export type LoaderKeys = `loader` | `loader/${keyof Loaders}`;
    // (undocumented)
    export type LocationKeys = `location/${keyof Locations & string}`;
    // @internal (undocumented)
    export type Name = `before` | `after` | `done` | `${ItemKeys}` | `${LocationKeys}` | `${LoaderKeys}` | `${Keys}` | `${RuleKeys}` | `${BuildHooks.Keys}`;
    // Warning: (ae-incompatible-release-tags) The symbol "Repository" is marked as @public, but its signature references "Name" which is marked as @internal
    export type Repository = {
        [K in Name as `${K & string}`]?: Hook[];
    };
    // (undocumented)
    export type RuleKeys = `rule` | `rule/${keyof Rules}` | `rule/${keyof Rules}/${keyof Webpack.RuleSetRule}` | `rule/${keyof Rules}/${keyof Webpack.RuleSetRule & `options`}/${string}`;
        {};
}

// @public
export type Index<T = any> = {
    [key: string]: T;
};

// @public
interface Interface {
    buildDependencies(): string[];
    directory(): string;
    hash(): string;
    version(): string;
}

// @public
interface Interface_2 {
    discover(type: 'dependencies' | 'devDependencies'): this;
    getPeerManifest(name: string): {
        [key: string]: any;
    };
    install(): void;
    isExtension(name: string): boolean;
    project: Project.Interface;
    registerDiscovered(): void;
    registerDiscovered(): void;
    resolvePeerByName(name: string): string;
}

// @public
interface Interface_3 extends Service {
    getProjectInfo(): {
        [key: string]: any;
    };
    hasPeerDependency(pkg: string): boolean;
    peers: Peers.Interface;
    resolveFrom: string[];
}

declare namespace Item {
    export {
        Item_2 as Interface,
        Item_3 as Abstract,
        Options_2 as Options,
        ConstructorOptions,
        Output
    }
}
export { Item }

// @public
interface Item_2 {
    loader: Factory<[Framework], Loader.Interface>;
    make(app: Framework): Output;
    mergeOptions(options: Options_2, app: Framework): void;
    options: Options_2;
    setLoader(factory: Maybe<[Framework], Loader.Interface>): void;
    setOptions(factory: Maybe<[Framework], Options_2>): void;
}

// @public
abstract class Item_3 {
    abstract loader: Factory<[Framework], Loader.Interface>;
    abstract make(app: Framework): Output;
    abstract mergeOptions(options: Options_2, app: Framework): void;
    abstract options: Factory<[Framework], Options_2>;
    abstract setLoader(factory: Maybe<[Framework], Loader.Interface>): void;
    abstract setOptions(factory: Maybe<[Framework], Options_2>): void;
}

// @public @virtual
export interface Items extends Partial<Index<Item.Interface>> {
}

declare namespace Loader {
    export {
        LoaderInterface as Interface,
        LoaderAbstract as Abstract,
        Factory_2 as Factory
    }
}
export { Loader }

// @public
abstract class LoaderAbstract implements LoaderInterface {
    abstract make(app: Framework): string;
    abstract normalizeInput<T = any>(input: Maybe<[Framework], T>): Factory<[Framework], T>;
    abstract src: Factory<[Framework], string>;
}

// @public
interface LoaderInterface {
    make(app: Framework): string;
    normalizeInput<T = any>(input: Maybe<[Framework], T>): Factory<[Framework], T>;
    src: Factory<[Framework], string>;
}

// @public @virtual
export interface Loaders extends Partial<Index<Loader.Interface>> {
}

// @public @virtual
export interface Locations extends Partial<Index<string>> {
}

// @public
export interface Logger extends Service {
    instance: Signale;
    // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: No member was found with name "name"
    //
    // (undocumented)
    name: 'logger';
}

// @public
export interface Loose {
    // (undocumented)
    [key: string]: any;
}

// Warning: (ae-internal-mixed-release-tag) Mixed release tags are not allowed for "make" because one of its declarations is marked as @internal
//
// @public
export function make(name: string, tap?: Tapable): Framework;

// @internal
export interface make {
    // (undocumented)
    (name: string, tap?: Tapable): Framework;
}

// @public
export type Maybe<A extends any[], T> = T | Factory<A, T>;

// @public
export type Mode = 'production' | 'development';

// @public @deprecated
export interface Module<P = any, O = any> extends Extension.Module<O> {
}

// @public
interface Module_2<Options = unknown> extends Loose {
    api?: Maybe<[Framework], Index<unknown>>;
    // @deprecated
    apply?: ApplyPlugin;
    boot?: Factory<[Framework], unknown>;
    // @deprecated
    make?: Maybe<[Container<Options>, Framework], ApplyPlugin>;
    name?: Name;
    options?: Maybe<[Framework], Options>;
    register?: Factory<[Framework], unknown>;
    when?: Maybe<[Framework, Container<Options>], boolean>;
}

// @public @virtual
export interface Modules extends Partial<Index<Extension.Module>> {
}

// @public
type Name = `${(keyof Modules & string) | (keyof Plugins & string)}`;

// @public (undocumented)
export interface Options {
    config?: Configuration;
    mode?: Mode;
    // @internal
    name: string;
    // @internal
    parent?: Framework;
    services?: Services;
}

// @public
interface Options_2 {
    // (undocumented)
    [key: string]: any;
}

// @public
interface Options_3 extends Partial<{
    test: Maybe<[Framework], RegExp>;
    use: Maybe<[Framework], Item.Interface[]>;
    exclude: Maybe<[Framework], RegExp>;
    type: Maybe<[Framework], string>;
    parser: Maybe<[Framework], Parser>;
    generator: Maybe<[Framework], any>;
}> {
}

// @public
interface Output {
    loader: string;
    options?: Options_2;
}

// @public
interface Output_2 extends Partial<{
    test: RegExp;
    use?: {
        loader: string;
        options?: {
            [key: string]: any;
        };
    }[];
    exclude?: RegExp;
    type?: string;
    parser?: Parser;
    generator?: any;
}> {
}

// @public
interface Parser {
    // (undocumented)
    parse: (input?: string) => any;
}

// @public (undocumented)
export interface path {
    // (undocumented)
    (this: Framework, key: keyof Locations & string, ...path: string[]): string;
}

// @public (undocumented)
export interface path {
    // (undocumented)
    (key: keyof Locations & string, ...path: string[]): string;
}

// @public (undocumented)
export const path: path;

// @public
interface Peer {
    name: string;
    source: string;
    type: 'dependencies' | 'devDependencies';
    ver: string;
}

declare namespace Peers {
    export {
        Peer,
        Repository,
        Abstract_3 as Abstract,
        Interface_2 as Interface
    }
}
export { Peers }

// Warning: (ae-forgotten-export) The symbol "Callback" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function pipe<T = Framework>(fns: Callback<T>[], value?: T): T;

// @public (undocumented)
export interface pipe {
    // (undocumented)
    <T = Framework>(fns: Callback<T>[], value?: T): T;
}

// @public
export interface PluginInstance {
    apply: CallableFunction;
}

// @public @virtual
export interface Plugins extends Partial<Index<Extension.CompilerPlugin>> {
}

declare namespace Project {
    export {
        Abstract_2 as Abstract,
        Interface_3 as Interface
    }
}
export { Project }

// @public
interface Repository {
    dependencies: {
        [key: string]: string;
    };
    devDependencies: {
        [key: string]: string;
    };
    extensions: {
        [key: string]: Peer;
    };
    name: string;
    peers: {
        [key: string]: Peer;
    };
}

declare namespace Rule {
    export {
        Rule_2 as Interface,
        Rule_3 as Abstract,
        Parser,
        Options_3 as Options,
        Output_2 as Output
    }
}
export { Rule }

// @public
interface Rule_2 {
    getExclude(app: Framework): Output_2['exclude'];
    getGenerator(app: Framework): any;
    getParser(app: Framework): Parser;
    getTest(app: Framework): RegExp;
    getType(app: Framework): Output_2['type'];
    getUse(app: Framework): Item.Interface[];
    make(app: Framework): Output_2 | RuleSetRule;
    setExclude(exclude: Maybe<[Framework], RegExp>): void;
    setGenerator(Generator: Maybe<[Framework], any>): void;
    setParser(parser: Maybe<[Framework], Parser>): void;
    setTest(test: Maybe<[Framework], RegExp>): void;
    setType(type: Maybe<[Framework], string>): void;
    setUse(use: Maybe<[Framework], Item.Interface[]>): void;
    test?(app?: Framework): RuleSetRule['test'];
    use?(app?: Framework): Item.Interface[];
}

// @public
abstract class Rule_3 {
    abstract getExclude(app: Framework): Output_2['exclude'];
    abstract getGenerator(app: Framework): any;
    abstract getParser(app: Framework): Parser;
    abstract getTest(app: Framework): RegExp;
    abstract getType(app: Framework): Output_2['type'];
    abstract getUse(app: Framework): Item.Interface[];
    abstract make(app: Framework): Output_2 | RuleSetRule;
    abstract setExclude(exclude: Maybe<[Framework], RegExp>): void;
    abstract setGenerator(Generator: Maybe<[Framework], any>): void;
    abstract setParser(parser: Maybe<[Framework], Parser>): void;
    abstract setTest(test: Maybe<[Framework], RegExp>): void;
    abstract setType(type: Maybe<[Framework], string>): void;
    abstract setUse(use: Maybe<[Framework], Item.Interface[]>): void;
    abstract test?(app?: Framework): RuleSetRule['test'];
    abstract use?(app?: Framework): Item.Interface[];
}

// @public @virtual
export interface Rules extends Partial<Index<Rule.Interface>> {
}

// Warning: (ae-forgotten-export) The symbol "Callback" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function sequence<T = Framework>(this: Framework, fns: Callback_2[], value?: T): Framework;

// @public (undocumented)
export interface sequence {
    // (undocumented)
    <T = Framework>(this: Framework, fns: Callback_2[], value?: T): Framework;
}

// Warning: (ae-internal-mixed-release-tag) Mixed release tags are not allowed for "Server" because one of its declarations is marked as @internal
//
// @public
export interface Server extends Service {
    application: Server.Application;
    assets: string[];
    close(): void;
    config: Server.Config;
    getWatchedFilesArray(): string[];
    inject(): void;
    instance: Server.Instance;
    isWatchable: boolean;
    middleware: Server.Middleware.Inventory;
    run(): this;
    watcher: {
        [key: string]: any;
        close: CallableFunction;
        on: CallableFunction;
    };
}

// @internal (undocumented)
export namespace Server {
    export type Application = Application;
    export type Compiler = Webpack.Compiler | Webpack.MultiCompiler;
    export type Config = Container<Configuration>;
    export interface Configuration {
        browser?: {
            log?: boolean;
            indicator?: boolean;
            overlay?: boolean;
        };
        disableHostCheck?: DevMiddleware.Options[];
        filename?: string;
        headers?: DevMiddleware.Options['headers'];
        host?: string;
        index?: DevMiddleware.Options['index'];
        methods?: DevMiddleware.Options['methods'];
        middleware?: {
            [key: string]: boolean;
        };
        mimeTypes?: DevMiddleware.MimeTypeMap;
        port?: number;
        proxy?: {
            host?: string;
            port?: number;
        };
        publicPath?: DevMiddleware.Options['publicPath'];
        watch?: {
            files: string[];
            options: WatchOptions;
        };
    }
    export type Instance = Server_2;
    export type Middleware = any;
    // (undocumented)
    export namespace Middleware {
        // (undocumented)
        export type Init = (options: Options) => Middleware;
        // (undocumented)
        export interface Inventory {
            // (undocumented)
            [key: string]: Middleware;
        }
        // (undocumented)
        export interface Options {
            // (undocumented)
            compiler: Compiler;
            // (undocumented)
            config: Config;
        }
        // (undocumented)
        export type Proxy = Proxy_2.RequestHandler & Handler;
        // (undocumented)
        export interface Target {
            // (undocumented)
            host: string;
            // (undocumented)
            port: number;
        }
    }
}

// Warning: (ae-forgotten-export) The symbol "GenericRepository" needs to be exported by the entry point index.d.ts
//
// @public
export abstract class Service<Repository = GenericRepository> extends Bootstrapper<Repository> {
    constructor(app: Framework);
    // Warning: (ae-forgotten-export) The symbol "GenericClassMap" needs to be exported by the entry point index.d.ts
    bindClass<ClassMap = GenericClassMap>(properties: ClassMap): void;
    // Warning: (ae-forgotten-export) The symbol "GenericFunctionMap" needs to be exported by the entry point index.d.ts
    bindMacro<FunctionMap = GenericFunctionMap>(properties: FunctionMap): void;
    // @virtual
    boot?(app: Framework): any;
    // @virtual
    booted?(app: Framework): any;
    // @virtual
    bootstrap?(app: Framework): any;
    // @virtual
    bootstrapped?(app: Framework): any;
    // @virtual
    register?(app: Framework): any;
    // @virtual
    registered?(app: Framework): any;
}

// @public @virtual
export interface Services extends Partial<Index<new (app: Framework) => Service>> {
}

// Warning: (ae-internal-mixed-release-tag) Mixed release tags are not allowed for "setPath" because one of its declarations is marked as @internal
//
// @public
export function setPath(this: Framework, ...args: any[]): Framework;

// @internal
export interface setPath {
    // (undocumented)
    (this: Framework, ...args: any[]): Framework;
}

// Warning: (ae-internal-mixed-release-tag) Mixed release tags are not allowed for "Store" because one of its declarations is marked as @internal
//
// @public
export class Store<T = Configuration> extends Service<T> {
    // @override (undocumented)
    get<T = any>(path: keyof Store.Repository): T;
    // Warning: (ae-unresolved-inheritdoc-reference) The @inheritDoc reference could not be resolved: No member was found with name "name"
    //
    // (undocumented)
    name: string;
}

// @internal (undocumented)
export namespace Store {
    // (undocumented)
    export type Keys = `${keyof Configuration & string}` | `theme.${keyof Configuration['theme'] & string}` | `theme.screens` | `theme.colors.${keyof Configuration['theme']['colors'] & string}` | `server.${keyof Configuration['server'] & string}` | `server.middleware.${keyof Configuration['server']['middleware'] & string}` | `server.browser.${keyof Configuration['server']['browser'] & string}` | `server.${keyof Configuration['server'] & string}.${string}` | `env.${string}` | `location.${keyof Configuration['location'] & string}` | `patterns.${keyof Configuration['patterns'] & string}` | `build.${keyof Webpack.Configuration}` | `build.module.${keyof Webpack.Configuration['module']}` | `build.module.${keyof Webpack.Configuration['module']}.${string}` | `extension.${string}` | `build.${keyof Webpack.Configuration}.${string}`;
    // (undocumented)
    export type Repository = {
        [K in Store.Keys & string]?: any;
    };
}

// @public (undocumented)
export interface tap<T = Framework> {
    // (undocumented)
    (fn: Tapable<[T]>, bound?: boolean): T;
}

// @public
export const tap: tap<Framework>;

// @public
export interface Tapable<P extends any[] = [Framework], T = any> extends Factory<[P], T> {
}

// @public @deprecated
export interface WebpackPlugin<P = any, O = any> extends Extension.CompilerPlugin<Extension.ApplyPlugin, unknown> {
}

// @public (undocumented)
export function when(this: Framework, test: ((app: Framework) => boolean) | boolean, trueCase: (app: Framework) => any, falseCase?: (app: Framework) => any): Framework;

// @public (undocumented)
export interface when {
    // (undocumented)
    (this: Framework, test: ((app: Framework) => boolean) | boolean, trueCase: (app: Framework) => any, falseCase?: (app: Framework) => any): Framework;
}

// Warnings were encountered during analysis:
//
// src/Configuration.ts:211:7 - (ae-forgotten-export) The symbol "TermColor" needs to be exported by the entry point index.d.ts

```
